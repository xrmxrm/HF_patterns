Identify the aspects of the application that vary and separate them from what stays the same. That is, encapsulate the parts that vary, so you can alter or extend tham without affecting the parts that don't vary.

Program to an interface, not an implementation. That is, program to a supertype.

Favor composition over inheritance.

Strive for loosely coupled designs between objects that interact.

Classes should be open for extension but closed for modification.

Dependency inversion principle: Depend on abstractions. Don't depend on concrete classes. High-level components should not depend on low-level components. They should both depend on abstractions. Guidelines (impossible to follow, but have a good reason for not following them):

  * No variable should hold a reference to a concrete class.

  * No class should derive from a concrete class.

  * No method should override an implemented method of
    any of its base classes.

Principle of least knowledge: Talk only to your immediate friends. Fewer dependencies --> robust system. More dependencies --> fragile system. Given an object, its methods should invoke only methods that belong to:

  * That object.

  * Objects referenced by the object's instance variables (HAS-A relationships).
    For example: 
      return station.getTemperature() 
    rather than 
      thermometer = station.getThermometer(); return thermometer.get Temperature()
    so not dependent on Thermometer class.

  * Objects passed as arguments to the method.

  * Objects the method creates or instantiates.

Hollywood principle: Don't call us, we'll call you. Low-level components can hook themselves in, but high-level components decide when/whether to call them.




PATTERNS
========

Strategy
--------
Define a family of algorithms; encapsulate each; make them interchangeable. This lets the algorithm vary independently from the client using it.

Observer
-------- 
Define a one-to-many dependency between objects so that when one object changes state, all of its dependents are notified and (either updated automatically or invited to pull updates). Observers and Subject are loosely coupled.

Decorator
---------
Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality. A decorator is a wrapper with the same superclass ()or interface as the wrapped object.

Factory Method
--------------
Defines an interface for creating an object, but lets subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.

Abstract Factory
----------------
Provide an interface for creating families of related dependent objects without specifying their concrete classes.

Singleton
---------
Ensure that a class has only one instance and provide a global point of access to it.

Simple idea, but issues include lazy vs eager instantiation, thread safety, multiple class loaders.

Command
-------
Encapsulate a request as an object, enabling you to parameterize other objects with different requests, queue or log requests, and support undoing operations.

It decouples the requestor of an action from the object that performs the action.

Null Object
-----------
Remove responsibility for handling nulls from clients by providing a surrogate that does nothing when executed.

Adapter
-------
Convert an object's interface into a different interface that the client expects.

Facade
------
Provide a unified (higher level, easy-to-use) interface to a set of interfaces in a subsystem.

Template Method
---------------
Define the structure of an algorithm in a class method, and let subclasses provide implementations for some steps. The abstract class can contain a hook: a concrete method that does nothing (but can be overridden or ignored by subclasses). Rule: Use an abstract method when the subclass must provide an implementation. Use a hook when implementing the method in the subclass is optional.