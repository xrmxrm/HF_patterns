Identify the aspects of the application that vary and separate them from what stays the same. That is, encapsulate the parts that vary, so you can alter or extend tham without affecting the parts that don't vary.

Program to an interface, not an implementation. That is, program to a supertype.

Favor composition over inheritance.

Strive for loosely coupled designs between objects that interact.

Classes should be open for extension but closed for modification.

Dependency inversion principle: Depend on abstractions. Don't depend on concrete classes. High-level components should not depend on low-level components. They should both depend on abstractions. Guidelines (impossible to follow, but have a good reason for not following them):

  * No variable should hold a reference to a concrete class.

  * No class should derive from a concrete class.

  * No method should override an implemented method of
    any of its base classes.


Strategy Pattern
----------------
Define a family of algorithms; encapsulate each; make them interchangeable. This lets the algorithm vary independently from the client using it.

Observer Pattern
---------------- 
Define a one-to-many dependency between objects so that when one object changes state, all of its dependents are notified and (either updated automatically or invited to pull updates). Observers and Subject are loosely coupled.

Decorator Pattern
-----------------
Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality. A decorator is a wrapper with the same superclass ()or interface as the wrapped object.

Factory Method Pattern
----------------------
Defines an interface for creating an object, but lets subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.